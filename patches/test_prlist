Bottom: 4e646b4a74b19c94f6fd9a711bf2d39c277febe4
Top:    c91c310d5b9e08c0266f8af25ac901855a3fc93f
Author: Igor Stoppa <igor.stoppa@huawei.com>
Date:   2018-05-31 17:12:49 +0300

test_prlist


---

diff --git a/include/linux/prlist.h b/include/linux/prlist.h
index 3154b5a4db80..3b143edfc2b1 100644
--- a/include/linux/prlist.h
+++ b/include/linux/prlist.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * prlist.h: Header for Protected Double Linked List
+ * prlist.h: Header for Protected Doubly Linked List
  *
  * (C) Copyright 2018 Huawei Technologies Co. Ltd.
  * Author: Igor Stoppa <igor.stoppa@huawei.com>
@@ -27,6 +27,18 @@ struct prlist_head *list_to_prlist(struct list_head *list)
 	return container_of(list, struct prlist_head, list);
 }
 
+static __always_inline
+struct prlist_head *prlist_prev(struct prlist_head *head)
+{
+	return list_to_prlist(head->list.prev);
+}
+
+static __always_inline
+struct prlist_head *prlist_next(struct prlist_head *head)
+{
+	return list_to_prlist(head->list.next);
+}
+
 struct prlist_pool
 *prlist_create_custom_pool(size_t refill, unsigned short align_order);
 
@@ -43,9 +55,9 @@ void *prlist_alloc(struct prlist_pool *pool, size_t size)
 	return pmalloc(&pool->pool, size);
 }
 
-static __always_inline void prlist_set_prev(struct prlist_pool *pool,
-					    struct prlist_head *head,
-					    const struct prlist_head *prev)
+static __always_inline
+void prlist_set_prev(struct prlist_pool *pool, struct prlist_head *head,
+		     const struct prlist_head *prev)
 {
 	void *dst = &head->list.prev;
 	const void *src = &prev->list;
@@ -56,9 +68,9 @@ static __always_inline void prlist_set_prev(struct prlist_pool *pool,
 		pmalloc_rare_write_ptr(&pool->pool, dst, src);
 }
 
-static __always_inline void prlist_set_next(struct prlist_pool *pool,
-					    struct prlist_head *head,
-					    const struct prlist_head *next)
+static __always_inline
+void prlist_set_next(struct prlist_pool *pool, struct prlist_head *head,
+		     const struct prlist_head *next)
 {
 	void *dst = &head->list.next;
 	const void *src = &next->list;
@@ -82,33 +94,56 @@ void INIT_STATIC_PRLIST_HEAD(struct prlist_head *head)
 	INIT_PRLIST_HEAD(NULL, head);
 }
 
-/*
 static __always_inline
-void prlist_set_next(struct prlist_head *head, struct list_head *next)
+void prlist_add(struct prlist_pool *pool, struct prlist_head *new,
+		struct prlist_head *head)
 {
+	struct prlist_head *next = list_to_prlist(head->list.next);
+
+	prlist_set_next(pool, new, next);
+	prlist_set_prev(pool, new, head);
+
+	prlist_set_prev(pool, next, new);
+	prlist_set_next(pool, head, new);
 }
 
-static inline struct prot_head *PROT_LIST_HEAD(struct prot_list_pool *pool)
+static __always_inline
+void prlist_add_tail(struct prlist_pool *pool, struct prlist_head *new,
+		     struct prlist_head *head)
 {
-	struct prot_head *head;
+	struct prlist_head *prev = list_to_prlist(head->list.prev);
 
-	head = pmalloc(&pool->pool, sizeof(struct prot_head));
-	if (WARN(!head, "Could not allocate protected list head."))
-		return NULL;
-	INIT_PROT_LIST_HEAD(pool, head);
-	return head;
+	prlist_set_next(pool, new, head);
+	prlist_set_prev(pool, new, prev);
 
+	prlist_set_prev(pool, head, new);
+	prlist_set_next(pool, prev, new);
 }
 
-static inline
-void prot_list_add(struct list_head *new, struct list_head *head)
+static __always_inline
+void prlist_del_entry(struct prlist_pool *pool, struct prlist_head *entry)
 {
-	__prot_list_add();
+	struct prlist_head *next;
+	struct prlist_head *prev;
+
+	next = list_to_prlist(entry->list.next);
+	prev = list_to_prlist(entry->list.prev);
+	prlist_set_prev(pool, next, prev);
+	prlist_set_next(pool, prev, next);
+	pmalloc_rare_write_ptr(&pool->pool, &entry->list.next, LIST_POISON1);
+	pmalloc_rare_write_ptr(&pool->pool, &entry->list.prev, LIST_POISON2);
 }
 
-static inline
-void prot_list_add_tail(struct list_head *new, struct list_head *head)
+static __always_inline void dump_prlist_head(struct prlist_head *head)
 {
+	pr_info("head: 0x%08lx   prev: 0x%08lx   next: 0x%08lx",
+		(unsigned long)head, (unsigned long)head->list.prev,
+		(unsigned long)head->list.next);
 }
-*/
+
+static inline void prlist_destroy_pool(struct prlist_pool *pool)
+{
+	pmalloc_destroy_pool(&pool->pool);
+}
+
 #endif
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index c40c7b734cd1..f67f209f1b99 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -2011,3 +2011,12 @@ config IO_STRICT_DEVMEM
 	  if the driver using a given range cannot be disabled.
 
 	  If in doubt, say Y.
+
+config DEBUG_PRLIST_TEST
+    bool "Testcase for Protected Double Linked List"
+    depends on STRICT_KERNEL_RWX
+    select PROTECTABLE_MEMORY
+    default n
+    ---help---
+      This option enables the testing of an implementation of double linked
+      list based on write protected memory.
diff --git a/lib/Makefile b/lib/Makefile
index 4ad867cc61a6..845ee4a1b825 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -266,3 +266,4 @@ obj-$(CONFIG_GENERIC_MULDI3) += muldi3.o
 obj-$(CONFIG_GENERIC_CMPDI2) += cmpdi2.o
 obj-$(CONFIG_GENERIC_UCMPDI2) += ucmpdi2.o
 obj-$(CONFIG_PROTECTABLE_MEMORY) += prlist.o
+obj-$(CONFIG_DEBUG_PRLIST_TEST) += test_prlist.o
diff --git a/lib/test_prlist.c b/lib/test_prlist.c
new file mode 100644
index 000000000000..58de923e660a
--- /dev/null
+++ b/lib/test_prlist.c
@@ -0,0 +1,124 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * test_prlist.c: Test cases for protected doubly linked list
+ *
+ * (C) Copyright 2018 Huawei Technologies Co. Ltd.
+ * Author: Igor Stoppa <igor.stoppa@huawei.com>
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/bug.h>
+#include <linux/prlist.h>
+
+
+#ifdef pr_fmt
+#undef pr_fmt
+#endif
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+static struct prlist_pool *pool;
+
+static struct prlist_head test_head __rare_write_after_init;
+static bool test_init_prlist_head(void)
+{
+	INIT_STATIC_PRLIST_HEAD(&test_head);
+	if (WARN(&test_head.list != test_head.list.prev ||
+		 &test_head.list != test_head.list.next,
+		 "initialization of static prlist_head failed"))
+		return false;
+	pr_info("initialization of static prlist_head passed");
+	return true;
+}
+
+
+struct test_data {
+	int d_int;
+	struct prlist_head list;
+	unsigned long long d_ulonglong;
+};
+
+#define LIST_NODES 5
+static bool test_build_prlist(void)
+{
+	short i;
+	struct test_data *node;
+	struct list_head *cursor;
+	int delta;
+
+	pool = prlist_create_pool();
+	if (WARN(!pool, "could not create pool"))
+		return false;
+
+	for (i = 0; i < LIST_NODES; i++) {
+		node = (struct test_data *)pmalloc(&pool->pool,
+						   sizeof(*node));
+		if (WARN(!node, "Failed to allocate list node"))
+			goto out;
+		pmalloc_rare_write_int(&pool->pool, &node->d_int, i);
+		pmalloc_rare_write_ulonglong(&pool->pool,
+					     &node->d_ulonglong, i);
+		prlist_add_tail(pool, &node->list, &test_head);
+	}
+	for (i = 1; i < LIST_NODES; i++) {
+		node = (struct test_data *)pmalloc(&pool->pool,
+						   sizeof(*node));
+		if (WARN(!node, "Failed to allocate list node"))
+			goto out;
+		pmalloc_rare_write_int(&pool->pool, &node->d_int, i);
+		pmalloc_rare_write_ulonglong(&pool->pool,
+					     &node->d_ulonglong, i);
+		prlist_add(pool, &node->list, &test_head);
+	}
+	i = LIST_NODES;
+	delta = -1;
+	list_for_each(cursor, &test_head.list) {
+		struct prlist_head *head;
+
+		i += delta;
+		if (!i)
+			delta = 1;
+		head = list_to_prlist(cursor);
+		node = container_of(head, struct test_data, list);
+		if (WARN(node->d_int != i || node->d_ulonglong != i,
+			 "unexpected value in list, build test failed"))
+			goto out;
+	}
+	pr_info("build list test passed");
+	return true;
+out:
+	prlist_destroy_pool(pool);
+	return false;
+}
+
+static bool test_teardown_prlist(void)
+{
+	short i;
+
+	for (i = 0; !list_empty(&test_head.list); i++)
+		prlist_del_entry(pool, list_to_prlist(test_head.list.next));
+	if (WARN(i != LIST_NODES * 2 - 1, "teardown test failed"))
+		return false;
+	prlist_destroy_pool(pool);
+	pr_info("teardown test passed");
+	return true;
+}
+
+static int __init test_prlist_init_module(void)
+{
+	if (WARN(!(test_init_prlist_head() &&
+		   test_build_prlist() &&
+		   test_teardown_prlist()),
+		 "protected list testing failed"))
+		return -EFAULT;
+	pr_info("protected list testing passed");
+	return 0;
+}
+
+module_init(test_prlist_init_module);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Igor Stoppa <igor.stoppa@huawei.com>");
+MODULE_DESCRIPTION("Test module for protected doubly linked list.");
