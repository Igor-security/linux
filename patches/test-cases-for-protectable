Bottom: ebb6471107e4f8e6baef946e9de3bf8bf1be2bbc
Top:    0f5fcd9ab0f0f0e11dc2c3b34a8df8ea4c392680
Author: Igor Stoppa <igor.stoppa@huawei.com>
Date:   2018-05-20 23:35:40 +0300

Test Cases for Protectable Memory allocator

The test cases cover several intended uses, for example:
- creating a pool
- allocating memory
- protecting a pool
- modifying an allocation
- destroying a pool

But also some possible abuses, for example trying to modify:
- memory from a read-only pool
- a static variable
- read only after init
- constant data

Signed-off-by: Igor Stoppa <igor.stoppa@huawei.com>


---

diff --git a/mm/Kconfig.debug b/mm/Kconfig.debug
index 8be4e5e1d349..d1fad2c450fc 100644
--- a/mm/Kconfig.debug
+++ b/mm/Kconfig.debug
@@ -101,3 +101,12 @@ config DEBUG_RARE_WRITE_AFTER_INIT_TEST
     ---help---
       This option enables a testcase for the rare-write mechanism, applied
       to statically allocated memory.
+
+config DEBUG_PROTECTABLE_MEMORY_TEST
+    tristate "Run self test for pmalloc memory allocator"
+    depends on STRICT_KERNEL_RWX
+    select PROTECTABLE_MEMORY
+    default n
+    ---help---
+      Tries to verify that pmalloc works correctly and that the memory is
+      effectively protected.
diff --git a/mm/Makefile b/mm/Makefile
index ddba59d1464e..b674d3e3ac1c 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -66,6 +66,7 @@ obj-$(CONFIG_SPARSEMEM_VMEMMAP) += sparse-vmemmap.o
 obj-$(CONFIG_SLOB) += slob.o
 obj-$(CONFIG_MMU_NOTIFIER) += mmu_notifier.o
 obj-$(CONFIG_PROTECTABLE_MEMORY) += pmalloc.o
+obj-$(CONFIG_DEBUG_PROTECTABLE_MEMORY_TEST) += test_pmalloc.o
 obj-$(CONFIG_KSM) += ksm.o
 obj-$(CONFIG_PAGE_POISONING) += page_poison.o
 obj-$(CONFIG_SLAB) += slab.o
diff --git a/mm/test_pmalloc.c b/mm/test_pmalloc.c
new file mode 100644
index 000000000000..9dc63ea4892a
--- /dev/null
+++ b/mm/test_pmalloc.c
@@ -0,0 +1,634 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * test_pmalloc.c
+ *
+ * (C) Copyright 2018 Huawei Technologies Co. Ltd.
+ * Author: Igor Stoppa <igor.stoppa@huawei.com>
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/bug.h>
+#include <linux/pmalloc.h>
+
+#ifdef pr_fmt
+#undef pr_fmt
+#endif
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#define SIZE_1 (PAGE_SIZE * 3)
+#define SIZE_2 1000
+
+/* wrapper for is_pmalloc_object() with messages */
+static inline bool validate_alloc(bool expected, void *addr,
+				  unsigned long size)
+{
+	bool test;
+
+	test = (is_pmalloc_object(addr, size) == GOOD_PMALLOC_OBJECT);
+	pr_info("must be %s: %s",
+		  expected ? "ok" : "no", test  ? "ok" : "no");
+	return test == expected;
+}
+
+#define is_alloc_ok(variable, size)	\
+	validate_alloc(true, variable, size)
+
+
+#define is_alloc_no(variable, size)	\
+	validate_alloc(false, variable, size)
+
+/* tests the basic life-cycle of a pool */
+static bool create_and_destroy_pool(void)
+{
+	static struct pmalloc_pool *pool;
+
+	pool = pmalloc_create_pool(PMALLOC_RO);
+	if (WARN(!pool, "Cannot allocate memory for pmalloc selftest."))
+		return false;
+	pmalloc_destroy_pool(pool);
+	pr_info("pool creation and destruction test passed");
+	return true;
+}
+
+/*  verifies that it's possible to allocate from the pool */
+static bool test_alloc(void)
+{
+	static struct pmalloc_pool *pool;
+	static void *p;
+
+	pool = pmalloc_create_pool(PMALLOC_RO);
+	if (WARN(!pool, "Unable to allocate memory for pmalloc selftest."))
+		return false;
+	p = pmalloc(pool,  SIZE_1 - 1);
+	pmalloc_protect_pool(pool);
+	pmalloc_destroy_pool(pool);
+	if (WARN(!p, "Failed to allocate memory from the pool"))
+		return false;
+	pr_info("allocation capability test passed");
+	return true;
+}
+
+/* tests the identification of pmalloc ranges */
+static bool test_is_pmalloc_object(void)
+{
+	struct pmalloc_pool *pool;
+	void *pmalloc_p;
+	void *vmalloc_p;
+	bool retval = false;
+
+	vmalloc_p = vmalloc(SIZE_1);
+	if (WARN(!vmalloc_p,
+		 "Unable to allocate memory for pmalloc selftest."))
+		return false;
+	pool = pmalloc_create_pool(PMALLOC_RO);
+	if (WARN(!pool, "Unable to allocate memory for pmalloc selftest."))
+		return false;
+	pmalloc_p = pmalloc(pool,  SIZE_1 - 1);
+	if (WARN(!pmalloc_p, "Failed to allocate memory from the pool"))
+		goto error;
+	if (WARN_ON(unlikely(!is_alloc_ok(pmalloc_p, 10))) ||
+	    WARN_ON(unlikely(!is_alloc_ok(pmalloc_p, SIZE_1))) ||
+	    WARN_ON(unlikely(!is_alloc_ok(pmalloc_p, PAGE_SIZE))) ||
+	    WARN_ON(unlikely(!is_alloc_no(pmalloc_p, SIZE_1 + 1))) ||
+	    WARN_ON(unlikely(!is_alloc_no(vmalloc_p, 10))))
+		goto error;
+	retval = true;
+	pr_info("is_pmalloc_object test passed");
+error:
+	pmalloc_protect_pool(pool); /* Protect to avoid WARNs on destroy */
+	pmalloc_destroy_pool(pool);
+	vfree(vmalloc_p);
+	return retval;
+}
+
+#define INSERT_OFFSET (PAGE_SIZE * 3 / 2)
+#define INSERT_SIZE (PAGE_SIZE * 2)
+#define REGION_SIZE (PAGE_SIZE * 5)
+/* Verify rare writes across multiple pages, unaligned to PAGE_SIZE. */
+static bool test_pmalloc_rare_write_array(void)
+{
+	struct pmalloc_pool *pool;
+	char *region;
+	char *mod;
+	unsigned int i;
+	int retval = false;
+
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	if (WARN(!pool, "Failed to create pool"))
+		return false;
+	region = pzalloc(pool, REGION_SIZE);
+	pmalloc_protect_pool(pool);
+	if (WARN(!region, "Failed to allocate memory from pool"))
+		goto destroy_pool;
+	mod = vmalloc(INSERT_SIZE);
+	if (WARN(!mod, "Failed to allocate memory from vmalloc"))
+		goto destroy_pool;
+	memset(mod, 0xA5, INSERT_SIZE);
+	retval = !pmalloc_rare_write_array(pool, region + INSERT_OFFSET,
+					   mod, INSERT_SIZE);
+	if (WARN(retval, "rare_write_array failed"))
+		goto free_mod;
+
+	for (i = 0; i < REGION_SIZE; i++)
+		if (i >= INSERT_OFFSET &&
+		    i < (INSERT_SIZE + INSERT_OFFSET)) {
+			if (WARN(region[i] != (char)0xA5,
+				 "Failed to alter target area"))
+				goto free_mod;
+		} else {
+			if (WARN(region[i] != 0,
+				 "Unexpected alteration outside ragion"))
+				goto free_mod;
+		}
+	retval = true;
+	pr_info("pmalloc_rare_write test passed");
+free_mod:
+	vfree(mod);
+destroy_pool:
+	pmalloc_destroy_pool(pool);
+	return retval;
+}
+
+/*
+ * The following functions test_pmalloc_rare_write_xxx() overwrite an
+ * element within an array and then verify that the change has happened as
+ * expected: the selected element has assumed the new value, while the
+ * others have not been affected.
+ */
+
+#define TEST_ARRAY_SIZE 5
+#define TEST_ARRAY_TARGET (TEST_ARRAY_SIZE / 2)
+
+static bool test_pmalloc_rare_write_char(void)
+{
+	struct pmalloc_pool *pool;
+	char *array;
+	unsigned int i;
+	bool retval;
+
+	retval = false;
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	if (WARN(!pool, "Failed to create pool"))
+		return false;
+	array = pmalloc(pool, sizeof(char) * TEST_ARRAY_SIZE);
+	if (WARN(!array, "Failed to allocate memory from pool"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		array[i] = (char)0xA5;
+	pmalloc_protect_pool(pool);
+	if (WARN(!pmalloc_rare_write_char(pool, array + TEST_ARRAY_TARGET,
+					  (char)0x5A),
+		 "Failed to alter char variable"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		if (WARN(array[i] != (i == TEST_ARRAY_TARGET ?
+				      (char)0x5A : (char)0xA5),
+			 "Unexpected value in test array."))
+			goto destroy_pool;
+	retval = true;
+	pr_info("rare_write_char test passed");
+destroy_pool:
+	pmalloc_destroy_pool(pool);
+	return retval;
+}
+
+static bool test_pmalloc_rare_write_short(void)
+{
+	struct pmalloc_pool *pool;
+	short *array;
+	unsigned int i;
+	bool retval;
+
+	retval = false;
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	if (WARN(!pool, "Failed to create pool"))
+		return false;
+	array = pmalloc(pool, sizeof(short) * TEST_ARRAY_SIZE);
+	if (WARN(!array, "Failed to allocate memory from pool"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		array[i] = (short)0xA5;
+	pmalloc_protect_pool(pool);
+	if (WARN(!pmalloc_rare_write_short(pool, array + TEST_ARRAY_TARGET,
+					   (short)0x5A),
+		 "Failed to alter short variable"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		if (WARN(array[i] != (i == TEST_ARRAY_TARGET ?
+				      (short)0x5A : (short)0xA5),
+			 "Unexpected value in test array."))
+			goto destroy_pool;
+	retval = true;
+	pr_info("rare_write_short test passed");
+destroy_pool:
+	pmalloc_destroy_pool(pool);
+	return retval;
+}
+
+static bool test_pmalloc_rare_write_ushort(void)
+{
+	struct pmalloc_pool *pool;
+	unsigned short *array;
+	unsigned int i;
+	bool retval;
+
+	retval = false;
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	if (WARN(!pool, "Failed to create pool"))
+		return false;
+	array = pmalloc(pool, sizeof(unsigned short) * TEST_ARRAY_SIZE);
+	if (WARN(!array, "Failed to allocate memory from pool"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		array[i] = (unsigned short)0xA5;
+	pmalloc_protect_pool(pool);
+	if (WARN(!pmalloc_rare_write_ushort(pool, array + TEST_ARRAY_TARGET,
+					    (unsigned short)0x5A),
+		 "Failed to alter unsigned short variable"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		if (WARN(array[i] != (i == TEST_ARRAY_TARGET ?
+				      (unsigned short)0x5A :
+				      (unsigned short)0xA5),
+			 "Unexpected value in test array."))
+			goto destroy_pool;
+	retval = true;
+	pr_info("rare_write_ushort test passed");
+destroy_pool:
+	pmalloc_destroy_pool(pool);
+	return retval;
+}
+
+static bool test_pmalloc_rare_write_int(void)
+{
+	struct pmalloc_pool *pool;
+	int *array;
+	unsigned int i;
+	bool retval;
+
+	retval = false;
+	pr_info("Testing rare_write_int");
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	if (WARN(!pool, "Failed to create pool"))
+		return false;
+	array = pmalloc(pool, sizeof(int) * TEST_ARRAY_SIZE);
+	if (WARN(!array, "Failed to allocate memory from pool"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		array[i] = 0xA5;
+	pmalloc_protect_pool(pool);
+	if (WARN(!pmalloc_rare_write_int(pool, array + TEST_ARRAY_TARGET,
+					 0x5A),
+		 "Failed to alter int variable"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		if (WARN(array[i] != (i == TEST_ARRAY_TARGET ? 0x5A : 0xA5),
+			 "Unexpected value in test array."))
+			goto destroy_pool;
+	retval = true;
+destroy_pool:
+	pmalloc_destroy_pool(pool);
+	return retval;
+}
+
+static bool test_pmalloc_rare_write_uint(void)
+{
+	struct pmalloc_pool *pool;
+	unsigned int *array;
+	unsigned int i;
+	bool retval;
+
+	retval = false;
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	if (WARN(!pool, "Failed to create pool"))
+		return false;
+	array = pmalloc(pool, sizeof(unsigned int) * TEST_ARRAY_SIZE);
+	if (WARN(!array, "Failed to allocate memory from pool"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		array[i] = 0xA5;
+	pmalloc_protect_pool(pool);
+	if (WARN(!pmalloc_rare_write_uint(pool, array + TEST_ARRAY_TARGET,
+					  0x5A),
+		 "Failed to alter unsigned int variable"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		if (WARN(array[i] != (i == TEST_ARRAY_TARGET ? 0x5A : 0xA5),
+			 "Unexpected value in test array."))
+			goto destroy_pool;
+	retval = true;
+	pr_info("rare_write_uint test passed");
+destroy_pool:
+	pmalloc_destroy_pool(pool);
+	return retval;
+}
+
+static bool test_pmalloc_rare_write_long(void)
+{
+	struct pmalloc_pool *pool;
+	long *array;
+	unsigned int i;
+	bool retval;
+
+	retval = false;
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	if (WARN(!pool, "Failed to create pool"))
+		return false;
+	array = pmalloc(pool, sizeof(long) * TEST_ARRAY_SIZE);
+	if (WARN(!array, "Failed to allocate memory from pool"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		array[i] = 0xA5;
+	pmalloc_protect_pool(pool);
+	if (WARN(!pmalloc_rare_write_long(pool, array + TEST_ARRAY_TARGET,
+					  0x5A),
+		 "Failed to alter long variable"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		if (WARN(array[i] != (i == TEST_ARRAY_TARGET ? 0x5A : 0xA5),
+			 "Unexpected value in test array."))
+			goto destroy_pool;
+	retval = true;
+	pr_info("rare_write_long test passed");
+destroy_pool:
+	pmalloc_destroy_pool(pool);
+	return retval;
+}
+
+static bool test_pmalloc_rare_write_ulong(void)
+{
+	struct pmalloc_pool *pool;
+	unsigned long *array;
+	unsigned int i;
+	bool retval;
+
+	retval = false;
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	if (WARN(!pool, "Failed to create pool"))
+		return false;
+	array = pmalloc(pool, sizeof(unsigned long) * TEST_ARRAY_SIZE);
+	if (WARN(!array, "Failed to allocate memory from pool"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		array[i] = 0xA5;
+	pmalloc_protect_pool(pool);
+	if (WARN(!pmalloc_rare_write_ulong(pool, array + TEST_ARRAY_TARGET,
+					   0x5A),
+		 "Failed to alter unsigned long variable"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		if (WARN(array[i] != (i == TEST_ARRAY_TARGET ? 0x5A : 0xA5),
+			 "Unexpected value in test array."))
+			goto destroy_pool;
+	retval = true;
+	pr_info("rare_write_ulong test passed");
+destroy_pool:
+	pmalloc_destroy_pool(pool);
+	return retval;
+}
+
+static bool test_pmalloc_rare_write_longlong(void)
+{
+	struct pmalloc_pool *pool;
+	long long *array;
+	unsigned int i;
+	bool retval;
+
+	retval = false;
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	if (WARN(!pool, "Failed to create pool"))
+		return false;
+	array = pmalloc(pool, sizeof(long long) * TEST_ARRAY_SIZE);
+	if (WARN(!array, "Failed to allocate memory from pool"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		array[i] = 0xA5;
+	pmalloc_protect_pool(pool);
+	if (WARN(!pmalloc_rare_write_longlong(pool,
+					      array + TEST_ARRAY_TARGET,
+					      0x5A),
+		 "Failed to alter long variable"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		if (WARN(array[i] != (i == TEST_ARRAY_TARGET ? 0x5A : 0xA5),
+			 "Unexpected value in test array."))
+			goto destroy_pool;
+	retval = true;
+	pr_info("rare_write_longlong test passed");
+destroy_pool:
+	pmalloc_destroy_pool(pool);
+	return retval;
+}
+
+static bool test_pmalloc_rare_write_ulonglong(void)
+{
+	struct pmalloc_pool *pool;
+	unsigned long long *array;
+	unsigned int i;
+	bool retval;
+
+	retval = false;
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	if (WARN(!pool, "Failed to create pool"))
+		return false;
+	array = pmalloc(pool, sizeof(unsigned long long) * TEST_ARRAY_SIZE);
+	if (WARN(!array, "Failed to allocate memory from pool"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		array[i] = 0xA5;
+	pmalloc_protect_pool(pool);
+	if (WARN(!pmalloc_rare_write_ulonglong(pool,
+					       array + TEST_ARRAY_TARGET,
+					       0x5A),
+		 "Failed to alter unsigned long long variable"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		if (WARN(array[i] != (i == TEST_ARRAY_TARGET ? 0x5A : 0xA5),
+			 "Unexpected value in test array."))
+			goto destroy_pool;
+	retval = true;
+	pr_info("rare_write_ulonglong test passed");
+destroy_pool:
+	pmalloc_destroy_pool(pool);
+	return retval;
+}
+
+static bool test_pmalloc_rare_write_ptr(void)
+{
+	struct pmalloc_pool *pool;
+	int **array;
+	unsigned int i;
+	bool retval;
+
+	retval = false;
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	if (WARN(!pool, "Failed to create pool"))
+		return false;
+	array = pmalloc(pool, sizeof(int *) * TEST_ARRAY_SIZE);
+	if (WARN(!array, "Failed to allocate memory from pool"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		array[i] = NULL;
+	pmalloc_protect_pool(pool);
+	if (WARN(!pmalloc_rare_write_ptr(pool, array + TEST_ARRAY_TARGET,
+					       array),
+		 "Failed to alter ptr variable"))
+		goto destroy_pool;
+	for (i = 0; i < TEST_ARRAY_SIZE; i++)
+		if (WARN(array[i] != (i == TEST_ARRAY_TARGET ?
+				      (void *)array : NULL),
+			 "Unexpected value in test array."))
+			goto destroy_pool;
+	retval = true;
+	pr_info("rare_write_ptr test passed");
+destroy_pool:
+	pmalloc_destroy_pool(pool);
+	return retval;
+
+}
+
+static bool test_specialized_rare_writes(void)
+{
+	if (WARN(!(test_pmalloc_rare_write_char() &&
+		   test_pmalloc_rare_write_short() &&
+		   test_pmalloc_rare_write_ushort() &&
+		   test_pmalloc_rare_write_int() &&
+		   test_pmalloc_rare_write_uint() &&
+		   test_pmalloc_rare_write_long() &&
+		   test_pmalloc_rare_write_ulong() &&
+		   test_pmalloc_rare_write_longlong() &&
+		   test_pmalloc_rare_write_ulonglong() &&
+		   test_pmalloc_rare_write_ptr()),
+		 "specialized rare writes test passedled"))
+		return false;
+	pr_info("specialized rare writes test passed");
+	return true;
+
+}
+
+/* Confirm that RO pools cannot be altered by rare write. */
+static bool test_illegal_rare_write_ro_pool(void)
+{
+	struct pmalloc_pool *pool;
+	int *var_ptr;
+	bool retval = false;
+
+	pr_info("Illegal rare_write to R/O pool - it should WARN");
+	pool = pmalloc_create_pool(PMALLOC_RO);
+	if (WARN(!pool, "Failed to create pool"))
+		return false;
+	var_ptr = pmalloc(pool, sizeof(int));
+	if (WARN(!var_ptr, "Failed to allocate memory from pool"))
+		goto destroy_pool;
+	*var_ptr = 0xA5;
+	pmalloc_protect_pool(pool);
+	if (WARN(pmalloc_rare_write_int(pool, var_ptr, 0x5A),
+		 "Unexpected successful write to R/O protected pool"))
+		goto destroy_pool;
+	retval = true;
+	pr_info("Illegal rare_write to RO pool test passed");
+destroy_pool:
+	pmalloc_destroy_pool(pool);
+	return retval;
+}
+
+static int rare_write_data __rare_write_after_init = 0xA5;
+static bool test_illegal_rare_write_static_rare_write_mem(void)
+{
+	struct pmalloc_pool *pool;
+	int *dummy;
+	bool write_result;
+
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	dummy = pmalloc(pool, sizeof(*dummy));
+	*dummy = 1;
+	pmalloc_protect_pool(pool);
+	pr_info("Illegal rare_write to static memory - it should WARN");
+	write_result = pmalloc_rare_write_int(pool, &rare_write_data, 0x5A);
+	pmalloc_destroy_pool(pool);
+	if (WARN(write_result || rare_write_data != 0xA5,
+		 "Unexpected successful write to static memory"))
+		return false;
+	pr_info("Illegal rare_write to static memory test passed");
+	return true;
+}
+
+static const int const_data = 0xA5;
+static bool test_illegal_rare_write_const(void)
+{
+	struct pmalloc_pool *pool;
+	int *dummy;
+	bool write_result;
+
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	dummy = pmalloc(pool, sizeof(*dummy));
+	*dummy = 1;
+	pmalloc_protect_pool(pool);
+	pr_info("Illegal rare_write to const - it should WARN");
+	write_result = pmalloc_rare_write_int(pool, &const_data, 0x5A);
+	pmalloc_destroy_pool(pool);
+	if (WARN(write_result || const_data != 0xA5,
+		 "Unexpected successful write to const memory"))
+		return false;
+	pr_info("Illegal rare_write to const memory test passed");
+	return true;
+}
+
+static int ro_after_init_data __ro_after_init = 0xA5;
+static bool test_illegal_rare_write_ro_after_init(void)
+{
+	struct pmalloc_pool *pool;
+	int *dummy;
+	bool write_result;
+
+	pool = pmalloc_create_pool(PMALLOC_RW);
+	dummy = pmalloc(pool, sizeof(*dummy));
+	*dummy = 1;
+	pmalloc_protect_pool(pool);
+	pr_info("Illegal rare_write to ro_after_init - it should WARN");
+	write_result = pmalloc_rare_write_int(pool, &ro_after_init_data, 0x5A);
+	pmalloc_destroy_pool(pool);
+	if (WARN(write_result || ro_after_init_data != 0xA5,
+		 "Unexpected successful write to ro_after_init memory"))
+		return false;
+	pr_info("Illegal rare_write to ro_after_init memory test passed");
+	return true;
+}
+
+static bool test_illegal_rare_writes(void)
+{
+	if (WARN(!(test_illegal_rare_write_ro_after_init() &&
+		   test_illegal_rare_write_static_rare_write_mem() &&
+		   test_illegal_rare_write_const() &&
+		   test_illegal_rare_write_ro_pool()),
+		 "illegal rare writes tests failed"))
+		return false;
+	pr_info("illegal rare writes tests passed");
+	return true;
+}
+
+/*
+ * test_pmalloc()  -main entry point for running the test cases
+ */
+static int __init test_pmalloc_init_module(void)
+{
+	if (WARN(!(create_and_destroy_pool() &&
+		   test_alloc() &&
+		   test_is_pmalloc_object() &&
+		   test_pmalloc_rare_write_array() &&
+		   test_specialized_rare_writes() &&
+		   test_illegal_rare_writes()),
+		 "protected memory allocator test failed"))
+		return -EFAULT;
+	pr_info("protected memory allocator test passed");
+	return 0;
+}
+
+module_init(test_pmalloc_init_module);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Igor Stoppa <igor.stoppa@huawei.com>");
+MODULE_DESCRIPTION("Test module for pmalloc.");
