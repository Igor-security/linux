Bottom: e923f38ac4d04eb2811b0ed3d00d1d60a272b418
Top:    31ff5be24fe93f179b905a4e2f6c5ea53477fe58
Author: Igor Stoppa <igor.stoppa@huawei.com>
Date:   2018-05-20 21:48:59 +0300

Double linked list using protected memory

In some cases, all the data needing protection can be allocated from a pool
in one go, as directly writable, then initialized and protected.
The sequence is relatively short and it's acceptable to leave the entire
data set unprotected.

In other cases, this is not possible, because the data will trickle over
a relatively long period of time, in a non predictable way, possibly for
the entire duration of hte operations.

For these cases, the safe approach is to have the memory already write
protected, when allocated. However, this will require replacing any
direct assignment with calls to rare_write().

The usual double linked list needs, therefore, to be replaced with a
derived variant that will replace direct writes, with rare_write().

This patch implements the most basic functionality.

Signed-off-by: Igor Stoppa <igor.stoppa@huawei.com>


---

diff --git a/include/linux/prlist.h b/include/linux/prlist.h
new file mode 100644
index 000000000000..77a5a18acacb
--- /dev/null
+++ b/include/linux/prlist.h
@@ -0,0 +1,82 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * prlist.h: Header for Protectable Double Linked List
+ *
+ * (C) Copyright 2018 Huawei Technologies Co. Ltd.
+ * Author: Igor Stoppa <igor.stoppa@huawei.com>
+ */
+
+#ifndef _LINUX_PRLIST_H
+#define _LINUX_PRLIST_H
+
+#include <linux/pmalloc.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+
+struct prlist_pool {
+	struct pmalloc_pool pool;
+};
+
+struct prlist_head {
+	struct list_head list;
+};
+
+static __always_inline
+struct prhead *list_to_prlist(struct list_head *list)
+{
+return NULL;
+	//	return container_of(list, struct prhead, list);
+}
+
+struct prlist_pool
+*prlist_create_custom_pool(size_t refill, unsigned short align_order);
+
+static inline
+struct prlist_pool *prlist_create_pool(void)
+{
+	return prlist_create_custom_pool(PMALLOC_REFILL_DEFAULT,
+					 PMALLOC_ALIGN_ORDER_DEFAULT);
+}
+
+static inline void *prlist_alloc(struct prlist_pool *pool, size_t size)
+{
+	return pmalloc(&pool->pool, size);
+}
+
+static inline void INIT_PRLIST_HEAD(struct prlist_pool *pool,
+				    struct prlist_head *head)
+{
+	void *pippo = &head->list;
+	pmalloc_rare_write(&pool->pool, &head->list.next, &pippo,
+			   sizeof(&head->list.next));
+}
+/*
+static __always_inline
+void prlist_set_next(struct prlist_head *head, struct list_head *next)
+{
+}
+
+static inline struct prot_head *PROT_LIST_HEAD(struct prot_list_pool *pool)
+{
+	struct prot_head *head;
+
+	head = pmalloc(&pool->pool, sizeof(struct prot_head));
+	if (WARN(!head, "Could not allocate protected list head."))
+		return NULL;
+	INIT_PROT_LIST_HEAD(pool, head);
+	return head;
+
+}
+
+static inline
+void prot_list_add(struct list_head *new, struct list_head *head)
+{
+	__prot_list_add();
+}
+
+static inline
+void prot_list_add_tail(struct list_head *new, struct list_head *head)
+{
+}
+*/
+#endif
diff --git a/lib/Makefile b/lib/Makefile
index ce20696d5a92..4ad867cc61a6 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -265,3 +265,4 @@ obj-$(CONFIG_GENERIC_LSHRDI3) += lshrdi3.o
 obj-$(CONFIG_GENERIC_MULDI3) += muldi3.o
 obj-$(CONFIG_GENERIC_CMPDI2) += cmpdi2.o
 obj-$(CONFIG_GENERIC_UCMPDI2) += ucmpdi2.o
+obj-$(CONFIG_PROTECTABLE_MEMORY) += prlist.o
diff --git a/lib/prlist.c b/lib/prlist.c
new file mode 100644
index 000000000000..457dd3aaaddc
--- /dev/null
+++ b/lib/prlist.c
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * prlist.c: Protected Double Linked List
+ *
+ * (C) Copyright 2018 Huawei Technologies Co. Ltd.
+ * Author: Igor Stoppa <igor.stoppa@huawei.com>
+ */
+
+#include <linux/prlist.h>
+
+struct prlist_pool *prlist_create_custom_pool(size_t refill,
+					      unsigned short align_order)
+{
+	struct prlist_pool *pool;
+
+	pool = kzalloc(sizeof(struct prlist_pool), GFP_KERNEL);
+	if (WARN(!pool, "Could not allocate pool meta data."))
+		return NULL;
+	pmalloc_init_custom_pool(&pool->pool, refill, align_order,
+				 PMALLOC_AUTO_RW);
+	return pool;
+}
+EXPORT_SYMBOL(prlist_create_custom_pool);
